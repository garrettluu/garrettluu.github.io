<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="styles/main.css">

    <meta charset="UTF-8">
    <title>
        Hello World
    </title>
</head>
<body>
    <div id="main">
    <div id="header">
        <h1 id="title">
            GARRETT LUU
            <div id="fancyrectangle">
            </div>
        </h1>
    </div>

    <ul class="nav">
        <li><a  href="index.html" id="navblog" class="active" >Blog</a></li>
        <li><a  href="about.html" id="navabout">About Me</a></li>
        <li><a  href="projects.html" id="navprojects">Projects</a></li>
    </ul>

    <div id="blog" class="m-scene">
        <div class="entry scene-element scene-element--fade">
            <h2>
                jQuery Fun and Newly Unearthed Bugs (Web Development - Day 3)
            </h2>
            <h3>
                2018.6.20
            </h3>
            <p>
                Today was rather uneventful, but I made some major changes to how the animations between pages are handled.
                Gone is the cumbersome and overdesigned "game of catch," and now we have proper smooth transitions between
                pages using jQuery and smoothState.js. Page loads are completely invisible, providing a more seamless
                experience in navigating the site. smoothState.js is nice in that it allows for animations to be easily
                called whenever you want them to be called, such as when you click the link or when the page finishes
                loading. This means that you don't need to put eventlisteners everywhere to check when animations have
                finished, and also allows for better timing of animations.
            </p>
            <p>
                The animations actually took longer than I initially thought to set up. After some fiddling, reading through
                what turned out to be deprecated examples, I got the page loading to be invisible, but the fade-out animation
                wasn't quite working. The fade-out was part of the .is-exiting class, which reverses the animation whatever
                you assigned it to. Turns out that the example used .m-scene.is-exiting, when .is-exiting is what actually
                worked. I just love it when people write things and provide inaccurate examples to supplement them.
            </p>
            <p>
                jQuery is also going to allow me to do more interesting things. Currently, each image that has the click-
                to-zoom feature has its own JavaScript, which is going to get impractical as more and more images
                are added to the site. With jQuery, I can get elements from the page based on className rather than id,
                which will allow me to apply scripts to multiple elements of a class at the same time rather than having
                to individually copy code for each one.
            </p>
            <p>
                    Finally, it seems I've found some new bugs that I wasn't aware of before. The click-to-zoom feature
                    causes the images to slip under the text of older blog posts. Images from older blog posts are fine
                    if there's a newer post under it, but look like this when over older posts.
            </p>
            <figure>
                <img src="styles/images/entry3.png" id="img3" width="500px" height="auto">
                <figcaption>I Fixed This Bug Already</figcaption>
            </figure>
            <p>
                My hypothesis on this is that the older images have the same z-index (which I tried changing to 10, but that
                didn't work), and since the older entries occur later on the html file, they end up being "layered" on
                top and take priority over the newer entries.
            </p>
            <p>
                However, as I was writing this, I decided to try some possible solutions. Putting the div for the zoomed image outside
                of the div for each blog entry turned out to be the correct way. We can now set the z-index of the zoomed
                image and the blog entries separately, so the zoomed images will always be on top.
                Who knew solutions could be so simple?
            </p>


        </div>
        <div id="entry3" class="img-zoom">
        <img class="zoom-content" id="img03">
        </div>
        <div class="entry scene-element scene-element--fade">
            <h2>
                A Game of Catch (Web Development - Day 2)
            </h2>
            <h3>
                2018.6.19
            </h3>
            <p>
                Testing out animations in JavaScript, and modified some parts of the site. You'll notice now that images
                have a click-to-zoom function, with some nice fade-in and fade-out animations to go along with it. I also
                experimented with a new way of handling navigation between pages. The site is now technically on one page,
                with fade transitions if you click on About and Blog (Projects is still not using this system). I came up
                with a clever, albeit inefficient way of handling this navigation and animations. Again, there's probably
                better ways to do this, but this is my solution for now.
            </p>
            <figure>
                <img src="styles/images/entry2.png" id="img2" width="372px" height="auto">
                <figcaption>Really Ugly Code I'm Sorry</figcaption>
            </figure>
            <p>
                When you click on one of the buttons, the animation for the current block of text starts, and creates a
                new blogeventlistener that waits for the end of the animation. When the animation ends, the next animation
                is started up, and an abouteventlistener is created. Now, were are on the other page, so going back to
                the original involves creating an abouteventlistener, which causes the blogeventlistener to also start up.
                I like to visualize this as a ball being thrown back and forth between the two eventlisteners (the ball
                in this case can be the nav variable, which changes depending on which option is selected).
            </p>
            <p>
                This game of catch is easy to replicate for two buttons, but becomes more difficult if we try
                to involve another player in the form of a third button. Another downside is that if you click the buttons
                too fast, the page will become stuck, and you'll need to refresh the page for the animations to work again.
                I'll try to find an easier, less insane way of implementing these fade animations in the future. More
                updates and fixes are coming soon.
            </p>

        </div>
        <div id="entry2" class="img-zoom">
            <img class="zoom-content" id="img02">
        </div>
        <div class="entry scene-element scene-element--fade">
            <h2>
                Web Development - Day 1
            </h2>
            <h3>
                2018.6.18
            </h3>
            <p>
                First blog entry! This website is my personal project as I attempt to learn web development. HTML was easy enough, CSS is
                awkward, and JavaScript doesn't really make sense yet. Obviously, I still have many things to learn in
                this process, and will need to break some habits I established with Java, C, and all those other OOP
                languages. I have done some JS in the past using JQueryUI, but none of that really applies to this site
                yet. Hopefully, I could keep this site simple, running only HTML and CSS as it is right now.
            </p>
            <p>
                My main problem with CSS is aligning elements with each other. Android XML has a convenient solution with
                LinearLayouts and ways to adjust spacing, as well as RelativeLayout to align elements relative to each
                other. In the image below, the whole space is a vertical LinearLayout, and each element in the list is
                a horizontal LinearLayout with the icon and text. While this is most likely not the most efficient method,
                it is incredibly easy to visualize and design our app layout around this principle of nested LinearLayouts.
            </p>
            <figure>
                <img src="styles/images/entry1.png" id="img1" width="310px" height="auto">
                <figcaption>Example of Linear Layouts</figcaption>
            </figure>
            <p>
                CSS doesn't seem to have an equivalent, and I don't want to resort to using tables and other junk
                instead of properly learning the conventions. Columns were the obvious solution at first, but can't have
                different lengths from each other unless I use various third-party frameworks. I'll just have to make do
                until I find a better solution, or find some framework that has similar functionality to LinearLayouts
                from Android.
            </p>
            <p>
                Web development isn't as hard as I thought it would be, but there is still a learning curve and surprises
                along the way. Hopefully I can improve my skills and learn more things along the way, and I'm excited to
                see where this journey takes me.
            </p>

        </div>
        <div id="entry1" class="img-zoom">
            <img class="zoom-content" id="img01">
        </div>
    </div>

    </div>
    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <script src="scripts/jquery.smoothState.js"></script>
    <script src="scripts/main.js"></script>
</body>
</html>